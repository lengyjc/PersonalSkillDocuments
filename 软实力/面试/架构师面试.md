# 架构师面试

## 如何理解架构师

1. 架构师的目的就是实现业务的增长

   1.1 增长的意思就是原有业务适应未来的变化

2. 具备调动资源的权利

   1.1 开发人员 执行落地

   1.2 如何调动资源，根据实际资源情况，动态调整

3. 类比军师

## 项目方面

1. 如何分析需求

   1.1 需求只是一个方案

   1.2 需求是谁提出来的

   1.3 需求的边界在哪里

   1.4 需求的核心点在哪里

   1.5 怎么去实现这个需求

   ​	举例子：表示你是否能够实践

2. 业务、技术、架构之间的关系

   2.1 业务是一个目标

   2.2 需要使用很多技术

   2.3 对技术的整合就是架构

3. 项目如何落地

   条件

   ​	1.拆分 

   ​		1.1 找到项目的核心点

   ​		1.2 分清非核心点

   ​		1.3 文件夹拆分，程序集拆分，项目式拆分

   ​	2.协调利益关系

   ​		2.1 项目是靠人完成的

   ​		2.2 只有自己用文件夹拆分，快速简单

   ​		2.3 如果具有很多人手，使用项目方式拆分

   ​		2.4 项目里面有很多通用的模块，使用程序集拆分

   4.总结

   ​	 4.1 框架是为了适应业务的变化，将更多的技术整合进来，实现一个业务目标

   ​	4.2 先抽象、后具体、再总结

   

## 系统设计方面

1. 如何设计一个高并发系统

   条件

   1.1 系统拆分：拆分子系统，形成集群，就可以抗住高并发

   1.2 缓存：大部分都是读多写少，redis单机可以轻松搞定几万的并发。用缓存来抗高并发

   1.3 MQ：解决数据库被频繁修改的CURD,同步瓶颈过大，改为异步提升并发量

   1.4 分库分表：降低查询数据量，提高sql性能

   1.5 读写分离：读的流量很大，从从库里读取数据，性能会更好

   1.6 Elasticsearch：本身就支持高并发量，承担数据库的读写压力

2. 细节具体情况具体分析，提出具体技术

3. 微服务和微服务架构关系

   3.1 微服务就是业务拆分

   3.2 微服务架构就是对微服务的整合

   ​		3.2.1 符合单一职责

   ​		3.2.2 微服务内有且只有一个服务

   ​		3.2.3 服务升级不会影响到其他服务

4. 分布式事务方案如何合理选择

   1. 单服务跨数据库

      2PC和3PC方案

   2. 不同服务不同数据库

      TCC和Saga

   3. 不同服务同数据库

      TCC和Saga

   4. 服务异步通信

      本地消息表cap

5. 可扩展性和伸缩性的区别

   5.1 可扩展性针对功能

   ​		5.1.1功能性

   ​		5.1.2如何实现

   ​		5.1.3条件

   ​				5.1.3.1 抽象类和接口

   ​				5.1.3.2 配置文件

   5.2伸缩性针对系统

   ​		5.2.1如何实现

   ​					注册中心机制

   5.3 举场景例子

   ​		文件上传增加上传类型（扩展）

   ​		商品微服务集群（伸缩性）

   

## 技术方面

1. 负载均衡算法和实现

   1.1 轮询算法

   1.2 加权轮询

   1.3 最小连接

   1.4 随机算法

   1.5 Hash一致性算法

2. 框架的实现

3. 依赖倒置IOC原则

   高层不依赖于低层，低层不依赖于高层，都依赖于抽象

   1. 零耦合关系

      如果两个类没有耦合关系，称为零耦合 

   2. 具体耦合关系

      如果两个具体类进行耦合，称为具体耦合

   3. 抽象耦合关系

      如果一个抽象类和一个具体类进行耦合，称为抽象耦合关系

4. 什么是AOP

   1. AOP 面向切面编程

   2. 动态给程序添加新功能，不改变原有代码

   3. 举例子 文件上传动态增加日志记录

   4. 如何实现

      动态代理，编译时、执行时

5. 海量日志数据，提取出某日访问网站次数最多的IP

   1. hash算法 每个IP进行hash存储到内存最后进行统计

## 基础方面

1. 对象之间的关系

   四类

   1.1 继承关系：继承抽象类和具体类

   1.2 实现关系：实现接口

   1.3 依赖关系：方法局部变量，方法的形参

   1.4 关联关系

   ​	1.4.1 聚合：成员变量表示 生命周期不同

   ​	1.4.2 组合：成员变量表示  生命周期相同

2. 迪米特法则

   1. 对于依赖的类最少了解

      1.1 通过例子回答是什么

      1.2 如何实现？封装

      1.3 封装的优缺点

   2. 类与类之间通信越少越好

3. 里式替换原则

   1.子类代替基类时，基类功能不会被修改

4. 接口和抽象类的区别

   1. 表示内容不同

      抽象类： 表示该类中已经有一些方法的具体实现

      接口：只定义方法，没有任何细节

   2. 性质不同

      抽象类：对对象的抽象

      接口：行为规范

   3. 成员变量不同

      抽象类：可以被不同修饰符修饰

      接口：成员变量都为常量

   